<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[django模型]]></title>
    <url>%2F2019%2F02%2F15%2Fdjango%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[poll教程第二节配置mysite/settingsDATABASE{} ， engine 用哪种数据库， name 数据存储文件名其它需要关注的配置：INSTALLED_APPS django数据库迁移时会检查installed apps中的应用涉及到的类，根据类生成sql。如果模块应用未添加到此配置，那么模块下models.py中定义的类不会生成表。TIME_ZONE USE_TZ 保持默认。大部分保持默认即可。 迁移migrate数据库 settings.py INSTALLED_APP 插上应用 python manage.py makemigrations polls 根据模块下models.py生成迁移脚本 (选做)python manage.py sqlmigration polls 0001 查看sql语句。 python manage.py migrate 执行迁移脚本 shellpython manage.py shell 与一般的python交互式解释器不同，还包含django上下文环境，拥有django相关功能。 orm操作 查询表中所有数据Question.objects.all() 返回model对应table的所有行 插入数据 默认自动提交。q = Question()q.save() 带条件查询类.objects.filter(列=值，列2=值2) 模糊匹配 字段后跟表示特殊操作开头类.objects.filter(字段startswith=’匹配子串’) 查询除了filter，也可以get，功能一致类.objects.get(列=值)get查询不到报异常。（推荐）filter查询不到返回空结果集。filter返回QuerySet结果集，get返回Question实例。 类实例相当于表中一行数据，可以调用实例方法q = Question.objects.get(id=1)q.方法() 反向查询需求，查询question表中“下周五考试吗”这个问题对应的选项，如果是sql，要先select id from question表 where text=“下周”得到qid，再select * from choice where question_id=qid;而orm帮我们只需要 q.关联表_set.all()。优点省一条查询代码缺点不太好理解。 一对多关系先把一的一方的表的一行数据get出来，q = Question.objects.get(id=1)然后反向查询关联创建q.choice_set.create(choice_text=’’) 删除q = Question.objects.get(id=1)q.delete() 更多查询语法参考官方文档/model layer/make queries或百度”django 查询” 注意：orm框架并非万能，较复杂的数据结构可能报错。可以手动在数据库简历表，不走migrate，只要保证models.py中的定义字段属性与数据库表一致。 报错 No module named ‘polls.apps.AppConfigdjango’;原因installapps项后忘加逗号。 django.core.exceptions.ImproperlyConfigured: ‘polls.apps.AppConfig’ must supply a name attribute.原因缺少django上下文，需要设置环境变量set DJANGO_SETTINGS_MODULE=mysite.settings 或在pycharm中运行 Admin管理后台介绍：数据库图形工具是针对专业人士的。为一般用户开发增删改查的后台代码比较重复。django提供了自动生成管理后台的admin插件。使用： 生成admin超管用户 python manage.py createsuperuser 注册model模块/admin.py注册 访问访问 服务地址/admin/]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前后端开发环境准备]]></title>
    <url>%2F2019%2F02%2F15%2F%E5%89%8D%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[nodejs 官网 下载LTS版本 安装程序一直next （组件默认全选node runtime，npm，add to path) node -v, npm -v查看版本 (选做)包管理工具npm cnpmnpm类似python中的pip，包管理工具。语法相似，默认install安装后只有本项目可用，类似python中的虚拟环境。注意-g参数，全局安装后windows终端可以使用命令。由于一些众所周知的原因。类似换pip源。 安装淘宝镜像npm install -g cnpm --registry=https://registry.npm.taobao.org 常用命令cnpm install xxx install 可以简写成icnpm install xxx -g -g参数代表global全局,安装完包后可以调用这个包的命令。类似django安装完后path下有一个django-admin.exe脚本。 (练习)安装httpserver包并开启局域网文件共享。npm install http-server -g (选做)IDE webstorm类似安装pycharm。 nodejs的包管理nodejs的包管理跟python相似但不同 package.json介绍:package.json是前端工程项目的依赖描述文件，类似pip中requirements.txt。安装依赖: cd到项目根目录后npm install安装。文件格式json。版本值说明: （比python pip描述的精细）2.3.11 分别为大版本、中版本、小版本号。latest最新版。^ 同一大版本下的最新版。 什么都不加确定某个版本。 node_modules执行npm install后项目根目录下生成node_modules，里面各种包，类似python解释器的site_package文件夹。类似python中的venv虚拟环境。这样的优点是：各项目开发环境独立确保稳定，跟python venv的优点一样。编译后为纯静态文件，丢到nginx下即可部署。缺点：不像python有公共内置包和成熟各领域常用包。每个项目都要安装，node_modules文件夹下常常三百多个package，网速不好的情况下安装起来比较痛苦。 (选做)其它后面用到的工具由于众所周知的原因，谷歌插件需要科学上网，下面几个工具重要但非必须。 vue-dev tools, 方便vue项目调试 postman 接口测试工具。可以寻找在线工具或requests包或curl 代替。 json-viewer awesome, 谷歌插件。可以在线工具或复制到ide中格式化 代替。 (课外)hexo博客 官网https://hexo.io/docs/ cnpm install -g hexo-cli 创建项目 hexo init [project-name] 安装依赖 cd到项目根目录 cnpm install 把静态资源和博客内容生成出来 hexo generate 开启web服务 hexo server 浏览器查看]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端 bootstrap]]></title>
    <url>%2F2019%2F01%2F31%2F%E5%89%8D%E5%90%8E%E7%AB%AFbootstrap%2F</url>
    <content type="text"><![CDATA[bootstrap之前已经学过css。css语法属性非常多，实现麻烦，效果一般。bootstrap是css封装的一套的ui框架，实现设计定义好了css样式，通过class方便引入。只需了解部分bootstrap class，就能开发出漂亮的前端界面，网上也有大量的模板直接修改。 下载版本选择 生产环境 去除空格的bs代码 bootstrap.min.css（生产） 源码 包含源码、bootstrap.min.css、bootstrap.css（学习）解压网站上下载源码压缩包，less 一种编程语言，写好后编译成css，浏览器才能解释。dist（distribution）文件夹，这个名字的文件夹下放的是编译好的css。 CDN 内容分发，在线引用bootstrap.css。（生产、学习） sass less bower npm 不需要了解，前端圈的东西，跟源代码编译和前端框架有关。现状新出了v4.0 但v3.3版本仍占市场大多数。vue等前端框架目前更火，但是上手简单、市场很多机遇bs的项目。有利于后端写出漂亮框架和为vue ui框架打下基础。 引用 项目本地引用 CDN 节省服务器流量。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装基础环境和初测项目]]></title>
    <url>%2F2019%2F01%2F29%2F%E5%AE%89%E8%A3%85%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E5%92%8C%E5%88%9D%E6%B5%8B%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[镜像的准备工作 apt更新源修改源 vim /etc/apt/sources.list更新源 apt-get update升级已安装的包 apt-get upgrade搜索 apt-cache search packagename安装 apt-get install packagename git mysql 注意记住密码 安全组放通端口 修改python软连接 初步测试运行（自带单线程） 本地验证可运行 生成依赖说明文件 pip freeze&gt; requirement.txt这个命令搭配虚拟环境比较好。否则全部包都会生成。可以选择pipreqs包生成项目所需依赖。 关闭debug模式。django settings.py中debug = False 设置接受的访问ip。allowedhost = [*] 或 [‘127.0.0.1’, ‘localhost’, ‘.example.com’, ‘39.96.114.97’] 。host头攻击原理https://blog.csdn.net/u012397189/article/details/80559028 以wsgi代理项目(django2版本不需操作，默认提供) sftp上传项目 安装项目依赖 cd到项目根目录下 pip3 install -r requirements.txt如果服务器没有pip3的话 apt install python3-pip 自带单线程启动 python manage.py runserver 0.0.0.0:8000这时的数据流是 外部ip→服务器上的django服务， 所以runserver 0.0.0.0。如果后面请求由nginx过来，那么runserver 127.0.0.1即可。 浏览器访问验证。https://域名:port 或 http://你的ip:port 其它常用软件 apt-get install python3-pip可以换pip源 apt-get install nano apt-get install gitgit生成密钥对后才能clone apt-get install mysql-server默认5.7版本，需要配置字符集才能插入中文。8.1版本需要官网下载deb包然后安装。参考https://www.cnblogs.com/wusr/p/10083754.html 报错 安装依赖是。一些包的安装方式与win不同。看安装到哪个包时报错。cairocffi 需要gcc编译，参考上面链接安装。mysqlclient包需要加载mysqlconfig。需要先安装mysql。pywin不需要。先手动去除requirements.txt项目中不需要的包 apt-get install python3-pip 后显示安装成功但无法使用pip3命令/usr/bin下没有。解决apt-get remove 卸载后重装。]]></content>
  </entry>
  <entry>
    <title><![CDATA[域名购买]]></title>
    <url>%2F2019%2F01%2F29%2F%E5%9F%9F%E5%90%8D%E8%B4%AD%E4%B9%B0%2F</url>
    <content type="text"><![CDATA[查看linux系统常用的命令，linux查看系统配置常用命令1 linux CPU大小cat /proc/cpuinfo |grep “model name” &amp;&amp; cat /proc/cpuinfo |grep “physical id”说明：Linux下可以在/proc/cpuinfo中看到每个cpu的详细信息。但是对于双核的cpu，在cpuinfo中会看到两个cpu。常常会让人误以为是两个单核的cpu。 内存大小cat /proc/meminfo |grep MemTotal 硬盘大小fdisk -l |grep Disk 查看内核/操作系统/CPU信息的linux系统信息命令uname -a 查看操作系统版本，是数字1不是字母Lhead -n 1 /etc/issue 查看CPU信息的linux系统信息命令cat /proc/cpuinfo 查看计算机名的linux系统信息命令hostname 列出所有PCI设备lspci -tv 列出所有USB设备的linux系统信息命令lsusb -tv 列出加载的内核模块lsmod 查看环境变量资源env 查看内存使用量和交换区使用量free -m 查看各分区使用情况df -h du -sh # 查看指定目录的大小 grep MemTotal /proc/meminfo # 查看内存总量 grep MemFree /proc/meminfo # 查看空闲内存量 uptime # 查看系统运行时间、用户数、负载 cat /proc/loadavg # 查看系统负载磁盘和分区 mount | column -t # 查看挂接的分区状态 fdisk -l # 查看所有分区 swapon -s # 查看所有交换分区 hdparm -i /dev/hda # 查看磁盘参数(仅适用于IDE设备) dmesg | grep IDE # 查看启动时IDE设备检测状况网络 ifconfig # 查看所有网络接口的属性 iptables -L # 查看防火墙设置 route -n # 查看路由表 netstat -lntp # 查看所有监听端口 netstat -antp # 查看所有已经建立的连接 netstat -s # 查看网络统计信息进程 ps -ef # 查看所有进程 top # 实时显示进程状态用户 w # 查看活动用户 id # 查看指定用户信息 last # 查看用户登录日志 cut -d: -f1 /etc/passwd # 查看系统所有用户 cut -d: -f1 /etc/group # 查看系统所有组 crontab -l # 查看当前用户的计划任务服务 chkconfig –list # 列出所有系统服务 chkconfig –list | grep on # 列出所有启动的系统服务程序 rpm -qa # 查看所有安装的软件包 cat /proc/cpuinfo ：查看CPU相关参数的linux系统命令 cat /proc/partitions ：查看linux硬盘和分区信息的系统信息命令 cat /proc/meminfo ：查看linux系统内存信息的linux系统命令 cat /proc/version ：查看版本，类似uname -r cat /proc/ioports ：查看设备io端口 cat /proc/pci ：查看pci设备的信息 在linux系统下检查postgresql数据库安装，登录及简单的查看 检查Linux系统是否安装数据库rpm -qa | grep postgresql 登录数据库su postgres 在输入命令psql这时等于系统用户postgres以同名数据库用户的身份，登录数据库，这是不用输入密码的。如果一切正常，系统提示符会变为”postgres=#”，表示这时已经进入了数据库控制台。 创建数据库创建数据库名字是 es;数据库 创建命令是 create database es； 附录 \h：查看SQL命令的解释，比如\h select。 \?：查看psql命令列表。 \l：列出所有数据库。 \c [database_name]：连接其他数据库。 \d：列出当前数据库的所有表格。 \d [table_name]：列出某一张表格的结构。 \du：列出所有用户。 \e：打开文本编辑器。 \conninfo：列出当前数据库和连接的信息。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux基础]]></title>
    <url>%2F2019%2F01%2F21%2FLinux%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[介绍Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。 特点基本思想Linux的基本思想有两点：第一，一切都是文件；第二，每个软件都有确定的用途。其中第一条详细来讲就是系统中的所有都归结为一个文件，包括命令、硬件和软件设备、操作系统、进程等等对于操作系统内核而言，都被视为拥有各自特性或类型的文件。至于说Linux是基于Unix的，很大程度上也是因为这两者的基本思想十分相近 多用户、多任务Linux支持多用户，各个用户对于自己的文件设备有自己特殊的权利，保证了各用户之间互不影响。多任务则是现在电脑最主要的一个特点，Linux可以使多个程序同时并独立地运行 其它特点：良好的界面（别信） 发行版之间关系粗略阅读下面的文章https://blog.csdn.net/u014554191/article/details/46534493https://www.caoxile.com/blog/2017/08/unixlinux%E5%92%8Cbsd%E7%9A%84%E5%85%B3%E7%B3%BB/debian ubuntu，良好的操作体验，市场占比大。redhat centos ，最早打入国内 场景服务器，生产环境，服务器用的软件丰富。个人用软件质量远不如win。桌面个人用户真没windows和macos好。没有孰优孰劣，场景和发展方向不同。 特性 一切皆文件。 开源免费 多用户 linux发行版基于linux内核，不同开发者根据需要加入软件，封装成了不同风格的linux系统，有的偏底层灵活，有的预装软件丰富开箱即用。这些不同的linux系统都叫做linux发行版之一。debian ubuntu kylin内置软件丰富，开箱即用。市场占比较高。centos 国内第一波linux学习者使用centos，国内占比较多。慢慢被ubuntu追上。redhat 红帽。商业公司开发运营。我为社区做贡献，社区帮我赚大钱。opensuse mint arch kyli 奶瓶 (课下)Unix BSD(任天堂游戏机) 推荐教程实验楼linux入门教程，边学边做，掌握基础后再上阿里云实际操作和部署网站https://www.shiyanlou.com/courses/1 实验环境 （初学时推荐）实验楼网站linux教程提供的在线linux。缺点延迟。 本机vmware或hyper-v。 缺点不能体验独立ip，域名，不利于理解服务端。 （推荐）阿里云等云服务器。缺点，价格，琳琅满目的功能让初学者迷惑。 (课外)虚拟化技术：vmware workstations、esix vspher。云虚拟化 kvm openstack 结论理解底层原理、提升逼格、升职加薪。下面的课程以最新稳定版ubuntu18.04讲解。 ubuntu版本选择https://www.ubuntu.com/download/server(推荐)Server服务器版(纯命令行) desktop桌面版(有桌面体验类似windows)安装包更大对硬件要求更高。版本介绍https://blog.csdn.net/zhengmx100/article/details/78352773（推荐）.04LTS 长期维护版，稳定。 .10(最新版，最新特性但没LTS稳定)目前最新长期版本的是18.04LTS。 目录根目录 / 。并没有windows的C 、D盘。根目下文件夹bin sbin可执行程序boot 系统启动，加载内核dev device 设备etc 配置 home 用户。相当于win上的C:\Userslib 安装程序的源代码存放位置root 超级管理员tmp 临时文件usr 放置杂物。放软件，网站]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django理论]]></title>
    <url>%2F2019%2F01%2F18%2Fdjango%E7%90%86%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[django版本：1.x 和 2.x，2.x不支持python2版本，1.x路由正则风格 2.x路由风格简单类似flask。 优点：大而全，封装多种功能，开箱即用。目录结构适合中大型程序。缺点，内含的功能有些用不上。 教程：投票应用 确认python版本和django版本已安装python -m django –version 新建工程项目django-admin startproject mysite 项目目录结构根目录下manage.py启动服务的入口。跟项目同名的mysite文件夹下主要项目代码。有的项目中找个文件夹又叫做app.src。settings.py设置，urls.py路由。wsgi.py打包应用部署相关。models.pyORM相关的类，views.py业务逻辑。 启动项目 python manage.py runserver 生成应用 python manage.py start app polls 。project是项目工程，app应用是项目中一个功能模块。polls目录下migrations是sql迁移脚本，admin.py后台插件、apps.py,models.py定义表结构的类，tests.py单元测试，views.py业务逻辑和HTML渲染。 数据流程浏览器请求url → mysite/urls.py → polls/urls.py → polls/views.py → 返回响应浏览器展示 报错 安装django时报目录权限错误。解决使用管理员piwershell pip安装。 代码修改后未生效，服务器无log。原因进程未正常退出。解决 改端口或任务管理器中结束所有python.exe getaddress函数报错。原因，计算机别名为中文 时间场景：你的网站世界用户都可访问。网站上线圣诞节活动，0点到24点结束，本国人正常，外国人访问发现活动开始和结束时间提前或延后。 背景知识TIME_ZONE=’UTC’USE_TZ=True不带时区的时间aware_time,带时区的时间local_time(本地时间)GMT,UTC(世界调和时) 中国东八区 UTC+8python内置的datetime包 now()生成本地时间。如果网站只有国内访问，USE_TZ 应该设置为False,时间可以由datetime包生成，存储数据库的是不带时区的本地时间。 django解决方案： 为了避免砂上面提到的场景，Django的解决方案是 由pytime_tz由time_zone() 生成带时区的时间，根据TIME_ZONE设置转换UTC时间存入数据库，html渲染时从取出UTC时间，根据访问者的时区转换成访问者当地时间。 最佳实践：1.国内访问，USE_TZ=False TIME_ZONE=’UTC’ datetime.now() time_zone()都行如果网站多国访问，USE_TZ应该设置为True 可能出现的错误：前台页面的时间比实际早8小时，原因USE_TZ=False TIME_ZONE=’Asia/shanghai’ i18ni18n意为国际化。网站上的菜单不同国家人访问展示不同的语言。原理有个翻译的配置文件。I18N=TRUE 保持默认开启]]></content>
  </entry>
  <entry>
    <title><![CDATA[js表单验证]]></title>
    <url>%2F2019%2F01%2F18%2Fjs%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[&lt;!DOCTYPE html&gt; js表单验证 function check_required(){ // 检查表单的邮箱是否已输入 var useremail_input = document.getElementsByName(“useremail”)[0]; console.log(useremail_input) if (useremail_input.value.length == 0) { alert(“邮箱不能为空”); return false; } } 用户名： 邮箱： 密码： 单选： 男 女 复选框： 体育 数学 阅读 英语 下拉列表： 学生 程序员 医生 文本域： 上传文件：]]></content>
  </entry>
  <entry>
    <title><![CDATA[scrapy 你知道吗]]></title>
    <url>%2F2019%2F01%2F16%2Fscrapy-%E4%BD%A0%E7%9F%A5%E9%81%93%E5%90%97%2F</url>
    <content type="text"><![CDATA[scrapyscrapy是一个流行的爬虫框架。架构分层，适合复杂项目并易于扩展。封装异步包，实现并发请求和分布式部署 框架架构介绍类似L45封装/baike_spider 项目，将爬虫项目分为几个更能层次 -引擎（scrapy engine)处理整个系统的数据流，触发事物-调度器(scheduler)接收引擎发过来的请求，压入队列，去重，决定下一次请求的url-下载器（downloader)根据url请求网页，下载网页原始内容，并将网页内容返回给spiders (基于twisted,异步请求) -爬虫(spiders)从网页信息中提取实体信息，返回单个实体item也可以提取链接供之后爬取-管道（pipeline)接收单个实体item,好像生长线一样进行加工验证item是否有效，持久化数据（写csv或数据库） -下载中间件，爬虫中间件，调度中间件(middle)上述主要模块无法满足的更细化或更前置的需求。例如django也有中间件，需求：用户进入视图函数前新建数据库链接，验证用户 sessionid,请求后要销毁数据库链接 ##运行流程1.引擎从调度器里去一个url接待器2.引擎接收到后封装为一个请求，交给下载器2.下载器请求网页，返回response4.爬虫解析response得到实体item5.item交给管道进行处理 安装scrapyscrapy依赖包比较多，有些包用c写的需要vc编译器 方法一： anacnda 自带上千种编译好的科学计算相关包。优点：自带编译后的scrapy缺点：体积大，下载包300M,安装一个多G,大多数包用不上，flask django又没有需要新下。miniconda是anaconda的精简版本。版本有限，缺少.net会导致报错失败。方法二： pip install scrapy 哪些报错需要vc编译器的，再单独去发布编译后的包的网站下载对应平台编译后的.whl文件安装参考链接： 第三编译后包的网站2.图文]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[json 查找各个地方呀]]></title>
    <url>%2F2019%2F01%2F14%2Fjson%E6%9F%A5%E6%89%BE%E6%89%80%E6%9C%89%E5%9C%B0%E6%96%B9%2F</url>
    <content type="text"><![CDATA[import urllib.requestimport urllib.parseimport json ab = input(‘请输入关键字’)cd = input(‘城市’) http://api.map.baidu.com/place/v2/suggestion?query=天安门&amp;region=北京&amp;city_limit=true&amp;output=json&amp;ak=你的ak //GET请求args = {‘query’: ab, ‘region’: cd, ‘output’: ‘json’,’ak’: ‘S2uzcu5og9j5h2tWPrBR9H0Fw8jiq9Wo’}b64_args = urllib.parse.urlencode(args)print(b64_args)base_url = ‘http://api.map.baidu.com/place/v2/search&#39;url = base_url + ‘?’ + b64_args resp = urllib.request.urlopen(url)content_json = resp.read().decode() json转对象content_obj = json.loads(content_json) results = content_obj[‘results’]for row in results: print(row[‘name’], row[‘address’])]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[doa]]></title>
    <url>%2F2019%2F01%2F11%2F%E7%AD%89%E4%BD%A0%E4%B8%8B%E8%AF%BE%2F</url>
    <content type="text"><![CDATA[随笔Jay：你住的 巷子里 我租了一间公寓 为了想与你不期而遇 高中三年 我为什么 为什么不好好读书 没考上跟你一样的大学 我找了份工作 离你宿舍很近 当我开始学会做蛋饼 才发现你 不吃早餐 喔 你又擦肩而过 你耳机听什么 能不能告诉我 合：躺在你学校的操场看星空 教室里的灯还亮着你没走 记得 我写给你的情书都什么年代了 到现在我还在写着 总有一天总有一年会发现 有人默默的陪在你的身边 也许 我不该在你的世界 当你收到情书 也代表我已经走远 Gary：学校旁 的广场 我在这等钟声响 等你下课一起走好吗]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>橙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动售货机]]></title>
    <url>%2F2019%2F01%2F11%2F%E8%87%AA%E5%8A%A8%E5%94%AE%E8%B4%A7%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[自动售货机goods_list =[{‘name’:’Coke Cola’,’stock’:40,’price’:3}, {‘name’:’Mineral water’,’stock’:40,’price’:2}, {‘name’:’cafe’,’stock’:40,’price’:5}]money = [{‘par value’:’一元’,’Initial quantity’:50},{‘par value’:’二元’,’Initial quantity’:30},{‘par value’:’五元’,’Initial quantity’:20},{‘par value’:’十元’,’Initial quantity’:10}]global balancebalance = 0def main_menu(): print(‘’’ 你好，有如下商品可供你选择： 1）.可乐-3 2）.矿泉水-2 3）.咖啡-5’’’)def pay_coin(): user_pay_num = int(input(‘投币:’)) if user_pay_num == 0: query_goods() elif user_pay_num == 1 or user_pay_num == 2 or user_pay_num == 5 or user_pay_num == 10: global balance balance = balance + user_pay_num else: print(‘Error’) pay_coin() if user_pay_num == 1: money[1][‘Initial quantity’] = money[1][‘Initial quantity’] + 1 if user_pay_num == 2: money[2][‘Initial quantity’] = money[2][‘Initial quantity’] + 1 if user_pay_num == 5: money[3][‘Initial quantity’] = money[3][‘Initial quantity’] + 1 if user_pay_num == 10: money[4][‘Initial quantity’] = money[4][‘Initial quantity’] + 1def chose_goods(): global balance print(‘按0退出’) order = int(input(‘需要点什么:’)) if order == 1: if goods_list[1][‘stock’] &gt; 0: if balance - 3 &gt;= 0: goods_list[1][‘stock’] = goods_list[1][‘stock’] - 1 balance = balance -3 print(‘咣当（饮料落地声）’) if balance != 0: chose_goods() else: print(‘欢迎下次使用’) else: print(‘请继续投币’) pay_coin() chose_goods() else: print(‘已售完’) chose_goods() elif order == 2: if goods_list[2][‘stock’] &gt; 0: if balance - 2 &gt;= 0: goods_list[2][‘stock’] = goods_list[2][‘stock’] - 1 balance = balance -2 print(‘咣当（饮料落地声）’) if balance != 0: chose_goods() else: print(‘欢迎下次使用’) else: print(‘请继续投币’) pay_coin() chose_goods() else: print(‘已售完’) chose_goods() elif order == 3: if goods_list[3][‘stock’] &gt; 0: if balance - 5 &gt;= 0: goods_list[3][‘stock’] = goods_list[3][‘stock’] - 1 balance = balance -5 print(‘咣当（饮料落地声）’) if balance != 0: chose_goods() else: print(‘欢迎下次使用’) else: print(‘请继续投币’) pay_coin() chose_goods() else: print(‘已售完’) chose_goods() elif order == 0: return_coin()def return_coin(): if balance == 1: money[1][‘Initial quantity’] = money[1][‘Initial quantity’] - 1 print(‘找零一元’) elif balance == 2: money[2][‘Initial quantity’] = money[2][‘Initial quantity’] - 1 print(‘找零二元’) elif balance == 3: money[1][‘Initial quantity’] = money[1][‘Initial quantity’] - 1 money[2][‘Initial quantity’] = money[2][‘Initial quantity’] - 1 print(‘找零三元’) elif balance == 4: money[2][‘Initial quantity’] = money[2][‘Initial quantity’] - 2 print(‘找零四元’) elif balance == 5: money[3][‘Initial quantity’] = money[3][‘Initial quantity’] - 1 print(‘找零五元’) elif balance == 6: money[1][‘Initial quantity’] = money[1][‘Initial quantity’] - 1 money[3][‘Initial quantity’] = money[3][‘Initial quantity’] - 1 print(‘找零六元’) elif balance == 7: money[2][‘Initial quantity’] = money[2][‘Initial quantity’] - 1 money[3][‘Initial quantity’] = money[3][‘Initial quantity’] - 1 print(‘找零七元’) elif balance == 8: money[1][‘Initial quantity’] = money[1][‘Initial quantity’] - 1 money[2][‘Initial quantity’] = money[2][‘Initial quantity’] - 1 money[3][‘Initial quantity’] = money[3][‘Initial quantity’] - 1 print(‘找零八元’) elif balance == 9: money[2][‘Initial quantity’] = money[2][‘Initial quantity’] - 2 money[3][‘Initial quantity’] = money[3][‘Initial quantity’] - 1 print(‘找零9元’) reset()def query_goods(): print(‘1).商品信息 2).钱盒信息 0).退出\n’) order1 = int(input(‘’)) if order1 == 1: print(‘商品序号’, ‘\t\t’, ‘商品名称’, ‘\t’, ‘库存’, ‘\t’, ‘价格’) print(‘-‘ 50) for i in range(0, len(goods_list)): print(i + 1, ‘\t\t\t’, goods_list[i][‘name’], ‘\t’, goods_list[i][‘stock’], ‘\t’, goods_list[i][‘price’]) elif order1 == 2: print(‘面值’, ‘\t’, ‘数量’) print(‘-‘ 50) for i in range(0, len(money)): print(money[i][‘par value’], ‘\t’, money[i][‘Initial quantity’]) elif order1 == 0: pay_coin(balance)def reset(): global balance balance = 0while True: main_menu() pay_coin() chose_goods()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[京东爬取数据]]></title>
    <url>%2F2019%2F01%2F10%2F%E4%BA%AC%E4%B8%9C%E8%AF%84%E8%AE%BA%E5%AD%98%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[京东评论写数据库simport requestsimport jsonfrom lxml import etreeimport pymysql.cursorsimport time def get_comments(product_id=None, page=None, page_size=10): “”” 取评论 :return: [[id,username,score,], []]或 [{‘id’:123123, ‘username’: ‘zzdxyz’, ‘score’: 5}] “”” comment_url = ‘https://sclub.jd.com/comment/productPageComments.action&#39; params = { &apos;productId&apos;: product_id, # 商品id。先写死 苹果手机。 &apos;score&apos;: 0, &apos;sortType&apos;: 5, &apos;page&apos;: page, &apos;pageSize&apos;: page_size, # &apos;callback&apos;: &apos;fetchJSON_comment98vv15261&apos;, # &apos;isShadowSku&apos;: 0, # &apos;fold&apos;: 1 } # 伪造headers。 降低被封禁的概率。 # cookie中有jsessionid和trackid和用户名等信息。referer请求前的页面地址。useragent浏览器标识。 headers = { &apos;cookie&apos;: &apos;shshshfpa=c5912ac8-f696-63a4-437d-20191204d1d8-1531666020; shshshfpb=01a876290501e22aca53c7218c89142ee978ad3d34afa32745b4ada524; pinId=uGywawhW5xQ; aud=c5a66c2779ef975e95c2e6bcd122076f; aud_ver=2; __jdu=15316322076781797028717; ipLocation=%u5317%u4EAC; ipLoc-djd=1-72-2799-0; avt=3; PCSYCityID=412; pin=zzdxyz; unick=%E7%BB%86%E8%BD%AF%E8%B7%91; _tp=EtAWqzuy%2FaNSh0LFcTfGgQ%3D%3D; _pst=zzdxyz; cn=0; user-key=bb1ddddd-6808-4a0a-9ef0-486272214fae; __jdc=122270672; TrackID=12_A_Uj3VhNwy96E08U546kjQ_OUDLBz9oe6SY1cKBy1gC5rvObnItC79-lh5xLhs1PpIIwwihGx4x848lXXJlC4IZxqw1EA3ZggiJZ6bX10; thor=1206B4BD372EF4F47D5ADB6E04093C1CF85E72A62CDA84A850575F6121C961C7920737265283260552283BC968C129ACF74176D4C8098D5A2F0F4FCB9EEB1943329E4CD3624DFB217BB4783B7FC6A054B9D577B323AFE4D0AC64F3456BB34D18C1441378FB2E314B30B0C41B982FD9C11F6993C370717B280220CBF466E16BF8; ceshi3.com=000; unpl=V2_ZzNtbUdfQhUlWxJdKx0OBmJREV9KV0QTd11CVH0dCAxlBBFfclRCFX0UR1RnGF4UZwIZXEZcRhZFCEdkexhdBGMBFFpHVnMldDhFVEsRbAVjARJaQFRAFHMPQF17H1QDZgAbW0JRcyVyOHYIP0AMQzkzElhEU0EQfAxDVEsYbAViBRpcR1VCFXA4DTp6VFwBZQMVX0FUQhNyDk9UfRFaBGQKFF1EZ0Ildg%3d%3d; __jda=122270672.15316322076781797028717.1531632208.1546481134.1546481144.36; __jdb=122270672.1.15316322076781797028717|36.1546481144; __jdv=122270672|dh.tbyuantu.com|t_1000537640_|tuiguang|4901abe8a5c24c2391673d5175e83623|1546481143668; shshshfp=66ae7625488a03ea74ef89c454100a41; shshshsID=3536f0e04a4e914beb2a3be569e1cb2d_1_1546481147922&apos;, &apos;referer&apos;: &apos;https://item.jd.com/100000287113.html&apos;, &apos;user-agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&apos;, } comment_resp = requests.get(url=comment_url, params=params, headers=headers) print(comment_resp.status_code) comment_str = comment_resp.text comment_dict = json.loads(comment_str) # comment_dict = json.load(&apos;4js接口-京东评论-评论数据.json&apos;) comments = comment_dict[&apos;comments&apos;] result_list = [] for comment in comments: result_list.append({ &apos;id&apos;: comment[&apos;id&apos;], &apos;content&apos;: comment[&apos;content&apos;], &apos;creation_time&apos;: comment[&apos;creationTime&apos;], &apos;score&apos;: comment[&apos;score&apos;], &apos;nickname&apos;: comment[&apos;nickname&apos;], &apos;product_color&apos;: comment[&apos;productColor&apos;], &apos;product_size&apos;: comment[&apos;productSize&apos;] }) return result_list def save_db(comments): “”” :param: comments: {list} [{‘id’:123123, ‘content’:’物美价廉东西不错’, },{}] :return: affected_rows : {int} 成功写入的行数 “”” connection = pymysql.connect(host=’127.0.0.1’, port=3306, user=’root’, password=’dadong’, db=’jd’, charset=’utf8mb4’, cursorclass=pymysql.cursors.DictCursor ) affected_rows = 0 # 成功计数 for comment in comments: # 循环评论 cursor = connection.cursor() # 创建游标 # 先判断一下是否已存储过 sql1 = &quot;select id from comment where comment_id=%s &quot; % (comment[&apos;id&apos;]) cursor.execute(sql1) rs_set = cursor.fetchone() # 有值返回{&apos;id&apos;:23} 无值返回None if rs_set: print(&apos;这条评论已存在在数据库中&apos;) continue # 不存在的写入数据库 # 写法一： 参数为列表或元组 占位符 %s # sql2 = &quot;&quot;&quot; # insert into comment (comment_id, content, creation_time, score, nickname, product_color, product_size) # values (%s, %s, %s, %s, %s, %s, %s,) # &quot;&quot;&quot; # 注意不要在拼sql的时候通过python字符串格式化（% .formate f&apos;&apos;）传参，应该cursor.execute(args=)传参。 # cursor.execute(sql2, args=(comment[&apos;id&apos;], comment[&apos;content&apos;], ...)) # 参数为列表或元组 # 写法二：参数为字典 sql2 = &quot;&quot;&quot; insert into comment (comment_id, content, creation_time, score, nickname, product_color, product_size) values (%(id)s, %(content)s, %(creation_time)s, %(score)s, %(nickname)s, %(product_color)s, %(product_size)s) &quot;&quot;&quot; affected_row = cursor.execute(sql2, args=comment) if affected_row: print(&apos;本条评论插入成功&apos;) affected_rows += affected_row # 写法三：批量插入，拼sql # 写法四：批量插入，用现成方法executemany connection.commit() return affected_rows if name == ‘main‘: product_id = 100000287113 # 先写死，固定为一个商品下的评论 page_amount = 10 # 爬取总页数，注意不要传给get_comments()函数导致每次请求固定的一页 page_size = 10 # 每页10条评论 time_sleep = 2 for page in range(0, page_amount): comments_list = get_comments(product_id, page, page_size) affected_rows = save_db(comments=comments_list) print(f&apos;成功写入{affected_rows}&apos;) time.sleep(2) print(&apos;Done&apos;) “””报错： id int默认4字节太短 应该bigint content中有单引号导致拼出的sql错误，应该在cursor.excutesql = ‘insert into comment (comment_id, content) values (%s, %s);’ % (111232, ‘物美价廉’)sql = ‘insert into comment (comment_id, content) values ({}, {});’.format(111232, ‘这个商品’太好’了！’)‘insert into comment (comment_id, content) values (111232, ‘这个商品’太好’了！’);’导致报错cursor.execute(sql)所以参数应该在cursor.execute(sql, args=(111232, ‘这个商品’太好’了！’)) indent error 缩进错误。 怀疑sql三引号中有一个空格，换行后变为5个空格。“”” “””批量插入：手动拼sql1.insert into comment(comment_id,content) values(111232,’这个商品太好了’), (11233,’不错’),(11233,’真好’);sql = ‘insert into comment (comment_id,content) values’for comment in comments: sql += ‘(‘ sql += comment[‘id’] sql +=comment[‘content’] sql += ‘)’ sql += ‘,’cursor.excute(sql)2.手动拼写比较麻烦容易出错，所以用现成的cursor.excutemany()sql = ‘insert into comment comment_id,“””]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python]]></title>
    <url>%2F2019%2F01%2F09%2F%E5%88%A4%E6%96%AD%E4%B8%AD%E8%8B%B1%E6%96%87%2F</url>
    <content type="text"><![CDATA[def is_chinese(uchar): “”” 判断是否为纯汉字 :param uchar: :return: “”” if uchar&gt;= u’\u4e00’ and uchar&lt;= u’\u9fa5’: return True else: return False def is_number(uchar): “”” 判断是否为纯数字 :param uchar: :return: “”” if uchar &gt;= u’\0030’ and uchar&lt;= u’\u0039’: return True else: return False def is_alphabet(uchar): &quot;&quot;&quot;判断一个unicode是否是英文字母&quot;&quot;&quot; if (uchar &gt;= u&apos;\u0041&apos; and uchar&lt;=u&apos;\u005a&apos;) or (uchar &gt;= u&apos;\u0061&apos; and uchar&lt;=u&apos;\u007a&apos;): return True else: return False def is_other(uchar): &quot;&quot;&quot;判断是否非汉字，数字和英文字符&quot;&quot;&quot; if not (is_chinese(uchar) or is_number(uchar) or is_alphabet(uchar)): return True else: return False def string2List(ustring): &quot;&quot;&quot;将ustring按照中文，字母，数字分开&quot;&quot;&quot; Chinese = [] # 中文字符 English = [] # 英文字符 Number = [] # 数字字符 Other = [] # 其他字符 for uchar in ustring: if is_chinese(uchar): Chinese.append(uchar) elif is_alphabet(uchar): English.append(uchar) elif is_number(uchar): Number.append(uchar) else: is_other(uchar) Other.append(uchar) if len(Chinese) != 0 and len(English) ==0 and len(Number) == 0 and len(Other)== 0: print(&apos;您输入的字符为纯汉字&apos;) elif len(Chinese) == 0 and len(English) != 0 and len(Number) == 0 and len(Other) == 0: print(&apos;您输入的字符为纯英文&apos;) elif len(Chinese) == 0 and len(English) == 0 and len(Number) != 0 and len(Other) == 0: print(&apos;您输入的字符为纯数字&apos;) elif len(Chinese) != 0 or len(English) != 0 or len(Number) != 0 or len(Other) != 0: print(&apos;您输入的字符为混合字符&apos;) else: print(&apos;您输入的字符为特殊字符&apos;) def run(): “”” 运行函数 :return: “”” while True: string = input(‘输入要测试的字符：’) string2List(string) is_next = input(‘y继续，任意字符退出：’) if is_next == ‘y’: run() else: break if name == “main“: run()]]></content>
  </entry>
</search>
